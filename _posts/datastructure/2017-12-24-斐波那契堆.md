---
layout: post
title: 斐波那契堆
categories: DataStructure
tags: [data-structure, Fibonacci-heap]
comments: true
---


# 斐波那契堆


## 斐波那契堆实现

    /**
     * description: FibHeap
     *
     * @author: zhuji
     * @date: Create at 2018/1/24 10:37
     */
    public class FibHeap {
    
        private Node root, min;
    
        private int length;
    
    
        public void makeHeap() {
            root = min = null;
            length = 0;
        }
    
        public void insert(int v) {
            Node x = new Node(v, 0, false, null, null);
            if (min == null) {
                x.left = x.right = x;
                root = min = x;
            } else {
                //add x to the root list
                insert(root, x);
                if (x.value < min.value)
                    min = x;
            }
            length++;
        }
    
        private void insert(Node src, Node target) {
            Node r = src.right;
            src.right = target;
            target.right = r;
            target.left = src;
            r.left = target;
        }
    
        public FibHeap union(FibHeap f1, FibHeap f2) {
            FibHeap heap = new FibHeap();
            heap.makeHeap();
            heap.min = f1.min;
            //链接 f1 和 f2 的根节点
            heap.root = linkTwoNodes(f1.root, f2.root);
    
            if (f1.min == null || (f2.min != null && f2.min.value < f1.min.value)) {
                heap.min = f2.min;
            }
            heap.length = f1.length + f2.length;
            return heap;
        }
    
        public Node extractMin() {
            Node z = min;
            if (z != null) {
                Node child = z.child, t = child;
                do {
                    //add t to the root list
                    if (t == null) break;
                    insert(root, t);
                    t.parent = null;
                    t = t.right;
                } while (t != child);
                //remove z from the root list
                z.left.right = z.right;
                z.right.left = z.left;
    
                if (z == z.right) {
                    min = null;
                } else {
                    min = z.right;
                    consoliDate(this);
                }
    
                length--;
            }
            return z;
        }
    
        private void consoliDate(FibHeap fibHeap) {
            int dn = (int) Math.floor((Math.log(fibHeap.length) / Math.log(2))) + 1;
            Node[] A = new Node[dn];
            Node w = fibHeap.root;
            do {
                int d = w.degree;
                Node x = w;
                while (A[d] != null) {
                    Node y = A[d];
                    if (x.value > y.value) {
                        swap(x, y);
                    }
                    heapLink(y, x);
                    A[d] = null;
                    d++;
                }
                w = w.right;
                A[d] = x;
            } while (w != fibHeap.root);
    
            fibHeap.min = null;
            for (int i = 0; i < dn; i++) {
                if (A[i] != null) {
                    if (fibHeap.min == null) {
                        fibHeap.root = fibHeap.min = A[i];
                        fibHeap.min = A[i];
                    } else {
                        insert(fibHeap.root, A[i]);
                        if (A[i].value < fibHeap.min.value) {
                            fibHeap.min = A[i];
                        }
                    }
                }
            }
        }
    
        private void heapLink(Node y, Node x) {
            //remove y from the root list
            y.left.right = y.right;
            y.right.left = y.left;
            //make y a child of x, x.degree++
            if (x.child == null) {
                x.child = y;
            } else {
                insert(x.child, y);
            }
            x.degree++;
        }
    
        private void swap(Node x, Node y) {
            Node t = x;
            x = y;
            y = t;
        }
    
        /**
         * 连接两个链表
         *
         * @param n1
         * @param n2
         * @return
         */
        private Node linkTwoNodes(Node n1, Node n2) {
            Node n1Right = n1, n2Right = n2;
            while (n1Right.right != n1 || n2Right.right != n2) {
                if (n1Right.right != n1) n1Right = n1Right.right;
                if (n2Right.right != n2) n2Right = n2Right.right;
            }
    
            n1Right.right = n2;
            n2.left = n1Right;
            n2Right.right = n1;
            n1.left = n2Right;
            return n1;
        }
    
        @ToString(exclude = {"left", "right"})
        static class Node {
            /**
             * degree: child 数目
             */
            int value, degree;
            boolean mark;
            Node left, right, parent, child;
    
            Node(int value, int degree, boolean mark) {
                this.value = value;
                this.degree = degree;
                this.mark = mark;
            }
    
            Node(int value, int degree, boolean mark, Node parent, Node child) {
                this(value, degree, mark);
                this.parent = parent;
                this.child = child;
            }
        }
    
        public static void main(String[] args) throws Exception {
            FibHeap heap1 = new FibHeap();
            heap1.insert(0);
            heap1.insert(2);
            FibHeap heap2 = new FibHeap();
            heap2.insert(-1);
            heap2.insert(3);
            FibHeap heap = heap1.union(heap1, heap2);
            Node n = heap.root;
            do {
                System.out.println(n);
                n = n.right;
            } while (n != heap.root);
        }
    
    }

