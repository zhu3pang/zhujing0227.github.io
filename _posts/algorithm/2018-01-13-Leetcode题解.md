---
layout: post
title: Leetcode 题解
categories: Algorithm
tags: [algorithm, Leetcode]
comments: true
---


# Two Sum

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

    Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1].


## 暴力求解 O(n<sup>2</sup>)

    two-sum(A, key):
    for i=1 to A.length-1
        for j=i+1 to A.length
            if A[i] + A[j] = key
                return [i,j]


## HashMap O(n)

保存数组的元素和索引, 遍历过程在 map 中找(key-A[i]), 若存在则返回[i, map.get(key-A[i])]

    private static int[] findTwoSum(int[] arr, int key) {
        Map<Integer, Integer> map = new HashMap<>(arr.length);
        for (int i = 0; i < arr.length; i++) {
            if (map.containsKey(key - arr[i])) {
                return new int[]{map.get(key - arr[i]), i};
            }
            map.put(arr[i], i);
        }
        throw new RuntimeException("No two sum solution");
    }

---


<a id="orga71244d"></a>

## 两数之和拓展&#x2013;输入有序数组

<https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/submissions/>

    public int[] twoSum(int[] numbers, int target) {
        if(numbers==null || numbers.length < 2) return null;
        int L=0, R=numbers.length-1;
        while(L<R){
            int sum = numbers[L] + numbers[R];
            if(sum==target) return new int[]{L+1, R+1};
            else if(sum<target) L++;
            else if(sum>target) R--;
        }
        return null;
    }


<a id="org8986116"></a>

# Three Sum

排序+双指针

    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        int len = nums.length;
        if(nums == null || len<3) return res;
        Arrays.sort(nums);
        for(int i = 0; i < len; i++){
            if(nums[i] > 0) break;
            if(i>0 && nums[i]==nums[i-1]) continue;
            int L = i + 1;
            int R = len - 1;
            while(L < R){
                int sum = nums[L] + nums[i] + nums[R];
                if(sum==0){
                    res.add(Arrays.asList(nums[L], nums[i], nums[R]));
                    while(L<R && nums[L] == nums[L+1]) L++;//去重
                    while(L<R && nums[R] == nums[R-1]) R--;//去重
                    L++;
                    R--;
                }else if(sum<0){
                    L++;
                }else if(sum>0){
                    R--;
                }
            }
        }
        return res;
    }


# Four Sum

<https://leetcode-cn.com/problems/4sum/>
排序+双指针, 见[2](#org8986116) [1.3](#orga71244d)

    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums == null || nums.length < 4) return res;
        int len = nums.length;
        Arrays.sort(nums);
        for (int i = 0; i < len - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < len - 2; j++) {
                if (j > i+1 && nums[j] == nums[j - 1]) continue;
                int L = j + 1;
                int R = len - 1;
                while (L < R) {
                    int sum = nums[i] + nums[j] + nums[L] + nums[R];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[L], nums[R]));
                        while(L<R && nums[L]==nums[L+1]) L++;//去重
                        while(L<R && nums[R]==nums[R-1]) R--;//去重
                        L++;
                        R--;
                    } else if (sum < target) {
                        L++;
                    } else {
                        R--;
                    }
                }
            }
        }
        return res;
    }


# Four Sum-ii

<https://leetcode-cn.com/problems/4sum-ii/>
<https://leetcode-cn.com/problems/4sum-ii/solution/chao-ji-rong-yi-li-jie-de-fang-fa-si-shu-xiang-jia/>

    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        int res = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<A.length; i++){
            for(int j=0; j<B.length; j++){
                int sumAB = A[i] + B[j];
                //记录出现sumAB的次数
                if(map.containsKey(sumAB)) map.put(sumAB, map.get(sumAB)+1);
                else map.put(sumAB, 1);
            }
        }
        for(int k=0; k<C.length; k++){
            for(int l=0; l<D.length; l++){
                int sumCD = -(C[k] + D[l]);
                if(map.containsKey(sumCD)) res += map.get(sumCD);
            }
        }
        return res;
    }


# Maximum Subarray 最大子数组

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2, 1, -3, 4, -1, 2, 1, -5, 4], 

the contiguous subarray [4, -1, 2, 1] has the largest sum = 6.


## 线性时间算法. O(n)

curSum 记录每次迭代 A[0..i]的最大子数组

    private static int maxSubArray(int[] arr) {
        if (arr.length == 1) return arr[0];
    
        int max = arr[0], curSum = arr[0];
        for (int i = 1; i < arr.length; i++) {
            curSum = Math.max(curSum + arr[i], arr[i]);
            max = Math.max(max, curSum);
        }
        return max;
    }


## 分治算法. O(nlg n)

最大子数组必定在左半部分/有半部分或跨越中间的, 分别计算三部分的最大子数组, 三者最大值即为最终的最大子数组.

    private static int maxSubArrayDivide(int[] arr, int left, int right) {
        if (left >= right) {
            return arr[left];
        }
    
        int mid = left + ((right - left) >> 1);
        //左半部分最大子数组
        int leftSum = maxSubArrayDivide(arr, left, mid);
        //右半部分最大子数组
        int rightSum = maxSubArrayDivide(arr, mid + 1, right);
        //跨越中点的最大子数组
        int crossSum = crossMiddle(arr, left, mid, right);
    
        return Math.max(leftSum, Math.max(rightSum, crossSum));
    }
    
    private static int crossMiddle(int[] arr, int left, int mid, int right) {
        int sum = 0, leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE;
        //从 mid 出发, 左边最大子数组
        for (int i = mid; i >= left; i--) {
            sum += arr[i];
            if (sum > leftMax) {
                leftMax = sum;
            }
        }
    
        sum = 0;
        //从 mid+1 出发右边最大子数组
        for (int i = mid + 1; i <= right; i++) {
            sum += arr[i];
            if (sum > rightMax) {
                rightMax = sum;
            }
        }
        return leftMax + rightMax;
    }


## 动态规划. O(n)

与线性时间一样, 只是保存了每一步的最大子数组

    public static int maxSubArrayDP(int[] arr) {
        //dp[i] means the maximum subarray ending with A[i];
        int[] dp = new int[arr.length];
        dp[0] = arr[0];
        int max = dp[0];
    
        for(int i = 1; i < arr.length; i++){
            dp[i] = Math.max(arr[i], dp[i-1] + arr[i]);
            max = Math.max(max, dp[i]);
        }
        return max;
    }

---


# Unique Paths 唯一路径

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


## 递归求解

当前位置的结果 = 从当前位置向下走一步的结果 + 与从当前位置向右走一步的结果

    private static int uniquePathsRecursive(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }
        if (m == 1 || n == 1) {
            return 1;
        }
        return uniquePathsRecursive(m, n - 1) + uniquePathsRecursive(m - 1, n);
    }


## 动态规划 O(m\*n)

递归存在大量重复的计算, 动态规划中使用数组保存了之前的计算结果.

    private static int uniquePaths(int m, int n) {
        int[][] tab = new int[m][n];
    
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    tab[i][j] = 1;
                } else {
                    tab[i][j] = tab[i - 1][j] + tab[i][j - 1];
                }
            }
        }
        return tab[m - 1][n - 1];
    }


## DP 优化: 空间复杂度从 O(m\*n)降到 O(min(m, n))

    private static int uniquePaths(int m, int n){
        //assume m >= n
        if(m < n){
            int t = m;
            m = n;
            n = t;
        }
        int[] tab = new int[n];
        tab[0] = 1;
    
        for(int i = 0; i < m; i++){
            for(int j = 1; j < n; j++){
                tab[j] += tab[j - 1];
            }
        }
        return tab[n - 1];
    }

---


# Unique Paths-ii

<https://leetcode-cn.com/problems/unique-paths-ii/>

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid[0].length == 0) return 0;
        int rol = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        for (int i = 0; i < rol; i++) {
            for (int j = 0; j < col; j++) {
                // 判断是否有障碍物，若有，当前点对结果贡献为0，直接置0即可
                if (obstacleGrid[i][j] == 1) {
                    obstacleGrid[i][j] = 0;
                    continue;
                }
                if (i == 0 && j == 0) {
                    obstacleGrid[i][j] = 1;
                } else if (i == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i][j - 1];// 第一行格点值等于左边格点值
                } else if (j == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j];// 第一列格点值等于上边格点值
                } else {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                }
            }
        }
        return obstacleGrid[rol - 1][col - 1];
    }


# Kth Largest Element in an Array

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

For example, 

Given [3, 2, 1, 5, 6, 4] and k = 2, return 5.


## 快排法   参考[快速排序](./排序之快排)

    public int findKthLargest(int[] arr, int p, int r, int k) {
        int q = partition(arr, p, r);
        int len = q - p + 1;
        if (len == k) {
            return arr[q];
        } else if (len < k) {
            return findKthLargest(arr, q + 1, r, k - len);
        } else {
            return findKthLargest(arr, p, q - 1, k);
        }
    }
    
    public static int partition(int[] arr, int p, int r) {
        int x = arr[r], i = p - 1;
        for (int j = p; j < r; j++) {
            if (arr[j] >= x) {
                //swap arr[++i] and arr[j]
                swap(arr, ++i, j);
            }
        }
        //swap arr[i+1] and arr[r]
        swap(arr, ++i, r);
        return i;
    }
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }


## 最小堆法  参考[最小堆法](./排序之堆排序)

用原数组 A[0, k-1]构建 k 个元素的最小堆, 遍历 A[k, A.length-1], if(A[0] < A[i]), then swap A[0] with A[i], 维护最小堆的性质, 遍历结束后 A[0]即为 Kth Largest Element in an Array.

    public static int findKthMaxWithMinHeap(int[] arr, int k) {
        MinHeapSort minHeapSort = new MinHeapSort(arr, k);  //用数组前 k 个数构建一个最小堆
        for (int i = k; i < arr.length; i++) {
            if (arr[0] < arr[i]) {
                swap(arr, 0, i);
                minHeapSort.minHeapify(0);
            }
        }
        return arr[0];
        //return Arrays.stream(arr).limit(k).toArray(); //返回前 k 个最大的数
    }

与之类似求 Kth Smallest Element in an Array 可以用[最大堆](./排序之堆排序)求解

---


# 链表


## Linked List Cycle 循环链表

Given a linked list, determine if it has a cycle in it.

利用快慢两个指针, 如果链表存在环, 那么必然存在某个点快慢两个指针重合.

    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
    
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast)    return true;
        }
        return false;
    }
    class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }


### 拓展

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

在判断了存在环的情况下, 设 head 节点到环起点距离为 A, 起点到 slow 节点距离为 B, 环长为 C.

slow 指针移动距离为 A+B, fast 指针移动距离为 A+B+C, 2(A+B) = A+B+C => C = A+B, slow 指针继续移动到起点的距离为 C-B = A, 即 head 与 slow 同步移动, 当 head==slow 时, 即为环的起点.

    2(F + a) = F + N(a + b) + a
    2F + 2a = F + 2a + b + (N - 1)(a + b)
    F = b + (N - 1)(a + b)

    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast){
                ListNode s = head;
                while (s != slow){
                    s = s.next;
                    slow = slow.next;
                }
                return s;
            }
        }
        return null;
    }

---


## intersection-of-two-linked-lists 链表相交

<https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/>

    /**
      * Definition for singly-linked list.
      * public class ListNode {
      *     int val;
      *     ListNode next;
      *     ListNode(int x) {
      *         val = x;
      *         next = null;
      *     }
      * }
      */
    public class Solution {
      public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
          定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
          两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
          **/
        if(headA == null || headB == null) return null;
        ListNode p1 = headA, p2 = headB;
        // 在这里第一轮体现在 pA 和 pB 第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果 pA 或 pB 相交就返回交点, 不相交最后就是 null==null
        while (p1 != p2) {
          p1 = p1 == null ? headB : p1.next;
          p2 = p2 == null ? headA : p2.next;
        }
        return p1;
      }
    }


## 反转链表 1

<https://leetcode-cn.com/problems/reverse-linked-list/>

    class LinkedCycle {
    
        public static ListNode reverse(ListNode head) {
            if (head == null || head.next == null) {
                return head;
            }
            ListNode pre = head, cur = head.next, next;
    
            while (cur != null) {
                next = cur.next;
                cur.next = pre;
    
                pre = cur;
                cur = next;
            }
    
            head.next = null;
            return pre;
        }
    
        private static ListNode reverseRecursive(ListNode head){
            if (head == null || head.next == null) {
                return head;
            }
            ListNode next = head.next;
            head.next = null;
            ListNode r = reverseRecursive(next);
            next.next = head;
            return r;
        }
    
        @ToString
        @AllArgsConstructor(staticName = "of")
        static class ListNode {
            int val;
            ListNode next;
    
            ListNode(int x) {
                val = x;
                next = null;
            }
        }
    }


## 反转链表 2

<https://leetcode-cn.com/problems/reverse-linked-list-ii/>

-   定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；
-   当前节点的下一个节点 3 调整为前驱节点的下一个节点 1->3->2->4->5,
-   当前结点仍为 2， 前驱结点依然是 1，重复上一步操作。。。
-   1->4->3->2->5.
    
        public ListNode reverseBetween(ListNode head, int m, int n) {
            if(head==null || head.next == null){
                return head;
            }
            ListNode tmp = new ListNode(0);
            tmp.next = head;
            ListNode pre = tmp;
            for(int i = 1; i<= m-1; i++){
                pre = pre.next;//定位到要反转部分头节点的前驱节点
            }
        
            head = pre.next;//要反转部分的头节点
            for(int i = m; i<n; i++){
                ListNode ne = head.next;
                //三次指针交换
                head.next = ne.next;
                ne.next = pre.next;
                pre.next = ne;
            }
        
            return tmp.next;
        }


## 删除链表的倒数第 N 个节点

<https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/>
<https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/dong-hua-tu-jie-leetcode-di-19-hao-wen-ti-shan-chu/>

    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode p = dummy, q = dummy;
        int i = 0;
        while(p.next!=null){
            p = p.next;
            if(i++>=n){
                q = q.next;
            }
        }
        //移除下一节点
        q.next = q.next.next;
        return dummy.next;
    }


## 两数相加

    <https://leetcode-cn.com/problems/add-two-numbers/>
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example

> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
> Output: 7 -> 0 -> 8
> Explanation: 342 + 465 = 807.

两个链表依次从低位开始相加, 新的链表节点只保存与 10 的余数(Sum%10), Sum/10 累加到高位, 一个链表到末尾节点后以 0 占位, 直至两链表都到末尾节点.

    private static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode listNode = new ListNode(0), curr = listNode;
        int carry = 0;
        while (l1 != null || l2 != null || carry != 0) {
            int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            carry = sum / 10;
    
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return listNode.next;
    }


## 两数相加 ii

三栈辅助
<https://leetcode-cn.com/problems/add-two-numbers-ii/>

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        Stack<Integer> s1 = new Stack<>(), s2 = new Stack<>(), s3 = new Stack<>();
        while (l1 != null) {
            s1.push(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            s2.push(l2.val);
            l2 = l2.next;
        }
    
        int carry = 0;
        while (!s1.isEmpty() && !s2.isEmpty()) {
            int sum = carry + s1.pop() + s2.pop();
            carry = sum / 10;
            s3.push(sum % 10);
        }
        while (!s1.isEmpty()) {
            int sum = carry + s1.pop();
            carry = sum / 10;
            s3.push(sum % 10);
        }
        while (!s2.isEmpty()) {
            int sum = carry + s2.pop();
            carry = sum / 10;
            s3.push(sum % 10);
        }
        if (carry>0) s3.push(carry);
    
        ListNode dummy = new ListNode(0);
        ListNode head = dummy;
        while (!s3.isEmpty()) {
            head.next = new ListNode(s3.pop());
            head = head.next;
        }
        return dummy.next;
    }


## 合并两个有序列表

<https://leetcode-cn.com/problems/merge-two-sorted-lists>


### 迭代

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                curr.next = l1;
                l1 = l1.next;
            }else{
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        curr.next = l1==null? l2 : l1;
        return dummy.next;
    }


### 递归

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l2.next, l1);
            return l2;
        }
    }


### 拓展&#x2013;合并两个有序数组

<https://leetcode-cn.com/problems/merge-sorted-array/>

    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m-1, index2 = n-1, index = m+n-1;
        while(index1>=0 && index2>=0){
            if(nums1[index1]>nums2[index2]){
                nums1[index] = nums1[index1];
                index1--;
                index--;
            }else{
                nums1[index] = nums2[index2];
                index2--;
                index--;
            }
        }
        System.arraycopy(nums2, 0, nums1, 0, index2+1);
    }


## 合并 K 个有序列表

<https://leetcode-cn.com/problems/merge-k-sorted-lists/>


### 优先队列

    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length==0){
            return null;
        }
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;
        final PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, Comparator.comparingInt(l -> l.val));
        for (ListNode node : lists) {
            if (node != null) {
                queue.add(node);
            }
        }
        while (!queue.isEmpty()){
            final ListNode pool = queue.poll();
            curr.next = new ListNode(pool.val);
            if (pool.next!=null){
                queue.add(pool.next);
            }
            curr = curr.next;
        }
        return dummy.next;
    }


### 分治

    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        if (lists.length == 1) return lists[0];
        if (lists.length == 2) return mergeTwoLists(lists[0], lists[1]);
    
        int mid = lists.length / 2;
        ListNode[] l1 = new ListNode[mid];
        System.arraycopy(lists, 0, l1, 0, mid);
        ListNode[] l2 = new ListNode[lists.length - mid];
        System.arraycopy(lists, mid, l2, 0, lists.length - mid);
    
        return mergeTwoLists(mergeKLists(l1), mergeKLists(l2));
    }
    
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l2.next, l1);
            return l2;
        }
    }


## 移除链表元素

<https://leetcode-cn.com/problems/remove-linked-list-elements/>

    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy, curr = dummy.next;
        while(curr!=null){
            if(curr.val==val){
                //移除节点
                pre.next = curr.next;
            }else{
                pre = pre.next;
            }
            curr = curr.next;
        }
        return dummy.next;
    }


## 删除排序列表中的重复元素

<https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/>

    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null) return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = head, curr = head.next;
        while(curr != null){
            if(pre.val == curr.val){
                //移除curr节点
                pre.next = curr.next;
            }else{
                pre = pre.next;
            }
            curr = curr.next;
        }
        return dummy.next;
    }


## 删除排序列表中的重复元素 ii

<https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/>
<https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/zhi-xing-yong-shi-1-ms-zai-suo-you-java-ti-jia-105/>

    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null) {
            int val = curr.next.val;
            if (curr.next.next != null && curr.next.next.val == val) {
                ListNode tmp = curr.next.next;
                while (tmp != null && tmp.val == val) {
                    tmp = tmp.next;//找到要删除的终点
                }
                curr.next = tmp;//移除所有重复节点
            } else {
                curr = curr.next;
            }
        }
        return dummy.next;
    }


## 两两交换链表中的节点

<https://leetcode-cn.com/problems/swap-nodes-in-pairs/>

    public ListNode swapPairs(ListNode head) {
        if (head==null || head.next==null) return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy, curr = head, ne;
        while (curr!=null && curr.next!=null){
            //交换相邻两节点
            ne=curr.next;
            pre.next = ne;
            curr.next = ne.next;
            ne.next = curr;
            //下一轮
            pre = curr;
            curr = curr.next;
        }
        return dummy.next;
    }


## 排序链表

<https://leetcode-cn.com/problems/sort-list/>

    public ListNode sortList(ListNode head) {
        if(head==null || head.next==null) return head;
        ListNode middle = middle(head);
        ListNode right = middle.next;
        middle.next = null;
    
        return merge(sortList(head), sortList(right));
    }
    
    public static ListNode middle(ListNode head){
        if(head==null || head.next==null) return head;
        ListNode slow = head, fast = head;
        while(fast.next!=null && fast.next.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    public static ListNode merge(ListNode l1, ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = merge(l1.next, l2);
            return l1;
        }else{
            l2.next = merge(l1, l2.next);
            return l2;
        }
    }


## 从链表中删去总和值为零的连续节点

HashMap 两轮遍历
<https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution/java-hashmap-liang-ci-bian-li-ji-ke-by-shane-34/>

    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
    
        Map<Integer, ListNode> map = new HashMap<>();
    
        // 首次遍历建立 节点处链表和<->节点 哈希表
        // 若同一和出现多次会覆盖，即记录该sum出现的最后一次节点
        int sum = 0;
        for (ListNode d = dummy; d != null; d = d.next) {
            sum += d.val;
            map.put(sum, d);
        }
    
        // 第二遍遍历 若当前节点处sum在下一处出现了则表明两结点之间所有节点和为0 直接删除区间所有节点
        sum = 0;
        for (ListNode d = dummy; d != null; d = d.next) {
            sum += d.val;
            d.next = map.get(sum).next;
        }
    
        return dummy.next;
    }


# water and jug  水壶问题

<https://leetcode-cn.com/problems/water-and-jug-problem/>

    /*
     * 这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为 x 和 y，
     * 问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为 z 升。
     * 那么我们可以用一个公式来表达：
     * z = m * x + n * y
     * 其中 m，n 为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，
     * 那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即 3 升的水罐往外倒了两次水，
     * 5 升水罐往里舀了两次水。那么问题就变成了对于任意给定的 x,y,z，存不存在 m 和 n 使得上面的等式成立。
     * 根据裴蜀定理，ax + by = d 的解为 d = gcd(x, y)，那么我们只要只要 z % d == 0，上面的等式就有解，
     * 所以问题就迎刃而解了，我们只要看 z 是不是 x 和 y 的最大公约数的倍数就行了，
     * 别忘了还有个限制条件 x + y >= z，因为 x 和 y 不可能称出比它们之和还多的水
     * */
    class Solution {
        public boolean canMeasureWater(int x, int y, int z) {
            return z==0 ||
                (z<=x+y && z%gcd(x,y)==0);
        }
    
        /**
        *  最大公约数：欧几里得算法
        * gcd(a,b) = gcd(b,a mod b)
        **/
        static int gcd(int x, int y){
            return y==0 ? x : gcd(y,x%y);
        }
    
        /**
        *最小公倍数：lcm(x,y)=x*y/gcd(x,y)
        */*
        static int lcm(int x, int y){
            return x*y/gcd(x,y);
        }
    }


# 过桥问题

<https://blog.csdn.net/xiji333/article/details/88072469>
n 个人要晚上过桥，在任何时候最多两个人一组过桥，每组要有一只手电筒。在这 n 个人中只有一个手电筒能用，因此要安排以某种往返的方式来返还手电筒，使更多的人可以过桥。

    object Bridge {
    
      def main(args: Array[String]): Unit = {
        val bridges = StdIn.readLine("输入过桥的人名及各自的时间")
          .split(" ")
          .map(l => {
            val split = l.split(",")
            split(0) -> split(1).toInt
          }).sortBy(_._2).toList
        calBridge(bridges, 0)
      }
    
      def calBridge(people: List[(String, Int)], time: Int): Unit = {
        people.size match {
          case 1 | 2 => {
            //A B 一块过桥 耗时 B
            println(s"${people.head._1} ${people.last._1} 过桥时间:${people.last._2}")
            println(s"总耗时: ${time + people.last._2}")
          }
          case 3 => {
            //A 送两次 耗时 B+A+C
            print(
              s"""|${people(1)._1} ${people.head._1} 过桥时间:${people(1)._2}
                  |${people.head._1} 返回时间:${people.head._2}
                  |${people(2)._1} ${people.head._1} 过桥时间:${people(2)._2}
                  |总耗时: ${time + people.map(_._2).sum}
                  |""".stripMargin)
          }
          case _ => {
            //A B C D
            //1. 最快的两个分别送两个最慢的过桥 B+A+D+B=A+2B+D
            //2. 最快者送最慢的两个过桥 C+A+D+A=2A+C+D
            val time1 = people.head._2 + 2 * people(1)._2 + people(3)._2
            val time2 = 2 * people.head._2 + people(2)._2 + people(3)._2
            if (time1 < time2) {
              print(
                s"""|${people(1)._1} ${people.head._1} 过桥时间:${people(1)._2}
                    |${people.head._1} 返回时间:${people.head._2}
                    |${people(2)._1} ${people(3)._1} 过桥时间:${people(3)._2}
                    |${people(1)._1} 返回时间:${people(1)._2}
                    |""".stripMargin)
              calBridge(people.take(people.size - 2), time + time1)
            } else {
              print(
                s"""|${people(2)._1} ${people.head._1} 过桥时间:${people(2)._2}
                   |${people.head._1} 返回时间:${people.head._2}
                    |${people(3)._1} ${people.head._1} 过桥时间:${people(3)._2}
                    |${people.head._1} 返回时间:${people.head._2}
                    |""".stripMargin)
              calBridge(people.take(people.size - 2), time + time2)
            }
          }
        }
      }
    }


# 位操作

[位操作奇技淫巧之原理加实践](https://mp.weixin.qq.com/s/99HVijYmbk1BrGVi1BqrCg)

    0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为 1，奇数位为 0）
    0x55555555 = 1010101010101010101010101010101 (偶数位为 0，奇数位为 1）
    0x33333333 = 110011001100110011001100110011 (1 和 0 每隔两位交替出现)
    0xcccccccc = 11001100110011001100110011001100 (0 和 1 每隔两位交替出现)
    0x0f0f0f0f = 00001111000011110000111100001111 (1 和 0 每隔四位交替出现)
    0xf0f0f0f0 = 11110000111100001111000011110000 (0 和 1 每隔四位交替出现)
    0xffffffff = 11111111111111111111111111111111


## single number


### 1 single-number1

<https://leetcode.com/problems/single-number/>

    /**
      * arr 中有一个数只出现一次, 其他数都是出现两次, 找出只出现一次的数.
      * [1,1,2,2,3] => 3
      */
    def singleNumber(nums: Array[Int]): Int = {
      nums.reduce(_^_)
    }


### 2 single-number2

<https://leetcode-cn.com/problems/single-number-ii/>

    /**
      * https://leetcode-cn.com/problems/single-number-ii, 老鼠试毒
      * arr 中只有一个数出现一次, 其他数都出现 k 次, 找出只出现一次的数
      * 假设输入中没有 single number，那么输入中的每个数字都重复出现了数字，也就是说，对这 32 位中的每一位 i 而言，所有的输入加起来之后，第 i 位一定是 3 的倍数。
      * 现在增加了 single number，那么对这 32 位中的每一位做相同的处理，也就是说，逐位把所有的输入加起来，并且看看第 i 位的和除以 3 的余数，这个余数就是 single numer 在第 i 位的取值。这样就得到了 single number 在第 i 位的取值。这等价于一个模拟的二进制，接着只需要把这个模拟的二进制转化为十进制输出即可
      */
    def uniqueNumberK(arr: Array[Int], k: Int): Int = {
      var ans = 0
      val len = arr.length
      val temp = Array.ofDim[Int](32)
      for (i <- 0 until 32) {
        for (j <- 0 until len) {
          temp(i) += ((arr(j) >> i) & 1)
        }
        temp(i) = temp(i) % k
        ans |= (temp(i) << i)
      }
      ans
    }


### 3 single-number3

<https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leetcode/>

    /**
      * arr 中有两个个数只出现一次, 其他数都是出现两次, 找出只出现一次的两个数.
      * 数组中所有数异或后的值就是出现一次的两个数异或的结果, 找到其第一次出现 1 的位数, 根据该位是否为 1 将数据分成两组,
      * 分别对两组数求异或值, 就能得到只出现一次的两个数
      * [1,1,2,2,3,4] => 3,4
      */
    def uniqueNumberV2(arr: Array[Int]): Array[Int] = {
      val xor = arr.reduce((a, b) => a ^ b)
      val mask = xor & (-xor)//保留位中最右边的 1
      var a = 0
      var b = 0
      for (i <- arr) {
        if ((i & mask) == 0) {
          a ^= i
        } else {
          b ^= i
        }
      }
      Array(a, b)
    }

---


## poor pigs 小白鼠试毒

<https://blog.csdn.net/haolexiao/article/details/72843286>

通用方法是讲试剂中哪瓶是毒品的信息总数表示出来为 N，然后再找出小白鼠所能表示的状态数目为 M，则需要的小白鼠个数为：K=logMN
而具体实验的操作方法为：

> 1.  将每种状态按照 M 进制进行编码，编码长度为 K
> 2.  每个小白鼠分别去拿自身的 M 中状态去实验 N 的 M 进制编码的某一位
> 3.  所以 K 个小白鼠，等同于是 K 长度 M 进制的对应的每一位
> 4.  这样试验完后，就确定了每一位上面的数字，找到对应的那种状态就好。


### 1 初级版问题——每只只能试一次

    /**
    * 1000 瓶水里有一瓶水有毒, 给 10 只小白鼠让找出有毒的是哪瓶
    * 1000 瓶水编号 1-1000, 10 只小白鼠按照二进制编号, 0 没喝水, 1 喝水了
    * 1 号瓶, 一号小白鼠喝 =>          0000000001
    * 3 号瓶, 一号和二号小白鼠都喝 =>   0000000011
    * .....
    * 最后看哪些小白鼠死了, 将 1 填充到对应的编号
    * 5,6 号死了 => 0000110000 => 48 号瓶有毒
    * 4,6,7,8 号四了 => 0011101000 => 232 号有毒
    */
    ceil(log(1000)/log(2)) = 10


### 2 中级版问题——每只可以实验多次

<https://leetcode-cn.com/problems/poor-pigs>

    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int scale = minutesToTest/minutesToDie + 1;//一只猪能代表的状态
        return (int) Math.ceil(Math.log(buckets)/Math.log(scale*1.0));
    }

---


## power of two

<https://leetcode-cn.com/problems/power-of-two/>

    /**
      * 231 https://leetcode-cn.com/problems/power-of-two/
      * 判断一个整数是否为 2 的幂次方
      * 4 => true, 5 => false
      * 4&3=>0, 8&7=>0
      */
    def powerOfTwo(num: Int): Boolean = {
      num > 0 && (num & (num - 1)) == 0
    }


### 1. power of three

<https://leetcode-cn.com/problems/power-of-two/>

    /**
      * 转成三进制后, 只有一位是 1
      * 1 =>  0001
      * 3 =>  0010
      * 9 =>  0100
      * 27=>  1000
      * 326 https://leetcode-cn.com/problems/power-of-three/
      *
      */
    def isPowerOfThree(n: Int): Boolean = {
      Integer.toString(n, 3).matches("10*")
    }


### 2. power of four

<https://leetcode-cn.com/problems/power-of-four/>

    /**
      * 342 https://leetcode-cn.com/problems/power-of-four/
      * 判断一个整数是否为 4 的幂次方
      * 4 的幂次方转为二进制后, 1 出现在奇数位上, 4=>3; 16=>5; 64=>7
      * 00000000000000000000000000000100  => 4
      * 00000000000000000000000000010000  => 16
      * 00000000000000000000000001000000  => 64
      * 如果是 4 的幂次方, 与 1010101010101010101010101010101 按位与后必然与自身相等
      */
    def powerOfFour(num: Int): Boolean = {
      //1010101010101010101010101010101
      num > 0 && (num & (num - 1)) == 0 && (num & 0x55555555) == num
    }

---


## missing number 缺失的數字

<https://leetcode-cn.com/problems/missing-number/>

    /**
      * 268
      * 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数
      * 0,1,3 => 2
      * 0,1,3 ^ 1,2,3 => 2
      **/
    def missingNumber(array: Array[Int]): Int = {
      var ans = 0
      for ((i, index) <- array.zipWithIndex) {
        ans ^= i
        ans ^= index + 1
      }
      ans
    }


## 数字范围按位与

<https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/>

    def rangeBitwiseAnd(m: Int, n: Int): Int = {
        var mask = 0xffffffff//11111111111111111111111111111111
        while ((mask & m) != (mask & n)) {
            mask = mask << 1
        }
        mask & m
    }

    def rangeBitwiseAnd(m: Int, n: Int): Int = {
        // n&(n-1)会把最后一个 1 后面所有位都置为 0,有点类似找 m 和 n 二进制的公共前缀
        var offset = 0//记录右移次数
        var mm = m
        var nn = n
        while(mm != nn){
            mm >>= 1
            nn >>= 1
            offset += 1
        }
        mm << offset
    }

    public int rangeBitwiseAnd(int m, int n) {
        while(n > m){//直到 m 大于等于 n
            n &= (n-1);
        }
        return n;
    }


## 位 1 的个数

<https://leetcode-cn.com/problems/number-of-1-bits/>

    public int hammingWeight(int n) {
        int res = 0;
        while(n!=0){
            if((n&1)==1) res+=1;
            n = n >>> 1;//注意用无符号右移
        }
        return res;
    }

    public int hammingWeight(int n) {
        int res = 0;
        while(n!=0){
            res+=1;
            n = n & (n - 1);
        }
        return res;
    }


## 颠倒二进制

<https://leetcode-cn.com/problems/reverse-bits/>

    //循环搬运 n 的各位到 ans 上
    public int reverseBits(int n) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans <<= 1;//ans 左移一位，给 n 的最后一位挪个窝
            ans += (n&1);//n 和 1 与，取出 n 的最后一位，放在 ans 的最后一位
            n >>= 1;//n 右移一位，把已经挪到 ans 中的最后一位释放掉
        }
        return ans;
    }


## 判断二进制的第 n 位为 1 或 0

    x & (1<<n)


## 将二进制的第 n 位设置为 1

    x | (1<<n)


## 将二进制的第 n 位设置为 0

    x & ~(1<<n)


## 二进制求和

<https://leetcode-cn.com/problems/add-binary/>

    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder("");
        int carry = 0;
    
        for(int i=a.length()-1, j=b.length()-1; i>=0||j>=0 ;i--,j--){
            int sum = carry + 
                (i>=0? a.charAt(i)-'0' : 0) +
                (j>=0? b.charAt(j)-'0' : 0);
            sb.append(sum%2);
            carry = sum/2;
        }
        if(carry==1) sb.append('1');
        return sb.reverse().toString();
    }


# 无重复字符的最长子串

<https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/>

    public int lengthOfLongestSubstring(String s) {
        int len = s.length(), ans = 0;
        Map<Character, Integer> map = new HashMap<>();
        for(int end=0, start=0; end<len; end++){
            if(map.containsKey(s.charAt(end))){
                start = Math.max(map.get(s.charAt(end)), start);
            }
            map.put(s.charAt(end), end+1);
            ans = Math.max(ans, end-start+1);
        }
        return ans;
    }


# 数组形式的整数加法

<https://leetcode-cn.com/problems/add-to-array-form-of-integer/>

    public List<Integer> addToArrayForm(int[] A, int K) {
        return addToArrayForm(A, A.length-1, K);
    }
    public List<Integer> addToArrayForm(int[] A, int end, int carry) {
        int sum = carry+A[end];
        A[end] = sum%10;
        carry = sum/10;
    
        if(end==0){
            List<Integer> res = new ArrayList<>();
            while(carry>0){
                res.add(carry%10);
                carry /= 10;
            }
            Collections.reverse(res);
            for(int i=0; i<A.length; i++){
                res.add(A[i]);
            }
            return res;
        }else{
            return addToArrayForm(A, end-1, carry);
        }
    }


# 重复的子字符串

<https://leetcode-cn.com/problems/repeated-substring-pattern/>
假设字符串有 n 个子串构成,则拼接后的子串为 2n 个,掐头去尾后为 2n-2 个,如果此时的字符串
至少包含一个原字符串,则说明至少包含 n 个子串,则 2n-2>=n,n>=2.则说明该字符串是周期性
结构,最少由两个子串构成.如果一个都不包含,即不包含 n 个子串,则说明 2n-2<n,n<2,即 n 为
1,也就是不符合周期性结构

    public boolean repeatedSubstringPattern(String s) {
        return (s+s).substring(1, s.length()*2-1).contains(s);
    }


# powx-n

<https://leetcode-cn.com/problems/powx-n/submissions/>

    public static double myPow(double x, int n) {
        int m = n >= 0 ? n : -n;
        double res = myPowRec(x, m);
        return n >= 0 ? res : 1 / res;
    }
    
    public static double myPowRec(double x, int n) {
        if (n == 0) return 1;
        if (n == 1) return x;
        double tmp = myPowRec(x, n / 2);
        if ((n & 1) == 0) {
            return tmp * tmp;
        } else {
            return tmp * tmp * x;
        }
    }


# 寻找重复数

<https://leetcode-cn.com/problems/find-the-duplicate-number/>

    /**
      * 287
      * 二分法。对“数”做二分，要定位的“数”根据题意在 1 和 n 之间，每一次二分都可以将搜索区间缩小一半。
      *
      * 以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，
      * 遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 [1,4)（注意：左闭右开）中；
      * 否则，重复的数存在于区间 [4,7]D（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），
      * 因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。
      */
    def findDuplicate(nums: Array[Int]): Int = {
      var left = 0
      var right = nums.length - 1
      while (left < right) {
        val mid = left + (right - left + 1) / 2
        var count = 0
        for (n <- nums) {
          if (n < mid) count += 1
        }
        if (count < mid) {
          left = mid
        } else {
          right = mid - 1
        }
      }
      left
    }


# 快乐数

<https://leetcode-cn.com/problems/happy-number/>

    /**
      * 202 https://leetcode-cn.com/problems/happy-number
      * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，
      * 也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数
      * 缓存每次计算的结果, 如果出现重复则说明跳进了循环, 直接退出
      */
    def isHappy(happy: Int): Boolean = {
      var h = happy
      var seed = Set(1)
      while (!seed.contains(h)) {
        seed = seed + h
        h = h.toString.map(i => Math.pow(i.toString.toInt, 2).toInt).sum
      }
      h == 1
    }

    //参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题
    //如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是
    //两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于 1。
    def isHappy(n: Int): Boolean = {
        var fast = n
        var slow = n
        do{
            slow = squareSum(slow)
            fast = squareSum(squareSum(fast))
        }while(slow!=fast)
        fast == 1
    }
    def squareSum(m:Int):Int={
        m.toString.map(i => Math.pow(i.toString.toInt, 2).toInt).sum
    }


# 各位相加

<https://leetcode-cn.com/problems/add-digits/>

    /**
      * 258 https://leetcode-cn.com/problems/add-digits/
      * 假设一个三位数整数 n=100*a+10*b+c,变化后 addn=a+b+c； 两者的差值 n-addn=99a+9b，差值可以被 9 整除，
      * 说明每次缩小 9 的倍数 那么我们可以对 res=num%9，若不为 0 则返回 res，为 0 则返回 9
      */
    def addDigits(num: Int): Int = {
      if (num > 0 && num % 9 == 0) 9 else num % 9
    }


# 最长回文子串

<https://leetcode-cn.com/problems/longest-palindromic-substring/>

    /**
      * 5 https://leetcode-cn.com/problems/longest-palindromic-substring/
      * https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/
      * P(i,j)=(P(i+1,j−1)&&S[i]==S[j])
      */
    def longestPalindrome(s: String): String = {
      val len = s.length
      var res = ""
      val dp = Array.ofDim[Boolean](len, len)
      for (i <- len - 1 to(0, -1)) {
        for (j <- i until len) {
          dp(i)(j) = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp(i + 1)(j - 1))
          if (dp(i)(j) && res.length < j - i + 1) {
            res = s.substring(i, j + 1)
          }
        }
      }
      res
    }


## 拓展&#x2013;中心扩展法

    public static String longestPalindrome(String s) {
        if (s == null || s.length() == 0) return "";
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len = Math.max(expandAround(s, i, i), expandAround(s, i, i + 1));
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
    
    public static int expandAround(String s, int L, int R) {
        while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
            L--;
            R++;
        }
        return R - L - 1;
    }


# 有效的括号

<https://leetcode-cn.com/problems/valid-parentheses/>

    /**
      * 20 https://leetcode-cn.com/problems/valid-parentheses/
      */
    def isValid(s: String): Boolean = {
      val map = Map(')' -> '(', '}' -> '{', ']' -> '[')
      val stack = new mutable.ArrayStack[Char]()
      for (c <- s) {
        if (map.contains(c)) {
          val top = if (stack.isEmpty) '#' else stack.pop()
          if (top != map(c)) return false
        } else {
          stack.push(c)
        }
      }
      stack.isEmpty
    }


# 简化路径

<https://leetcode-cn.com/problems/simplify-path/>

    /**
      * 71 https://leetcode-cn.com/problems/simplify-path/
      * 简化路径
      */
    def simplifyPath(s: String): String = {
      val stack = new mutable.ArrayStack[String]()
      s.split("/")
        .foreach(c => {
          if (c.equals("..")) {
            if (stack.nonEmpty) stack.pop()
          } else if (c.nonEmpty && !c.equals(".")) {
            stack.push(c)
          }
        })
      "/" + stack.toList.reverse.mkString("/").replaceFirst("/$", "")
    }


# 玻璃杯检测

[玻璃被检测](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484557&idx=1&sn=739d80488fe1169a9c9ca26ecfcdfba6&chksm=fa0e6b0ccd79e21a1c2b0d99db69f6206cddddfe2367742e9de1d7d17ec35a5ce29fa4e30d63&token=110841213&lang=zh_CN#rd)

    /**
      * 有一种玻璃杯质量确定但未知，需要检测。
      * 有一栋 100 层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。
      * 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎
      * W(n, k) = 1 + min{max(W(n -1, x -1), W(n, k - x))}, x in {2, 3, ……，k}
      * https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484557&idx=1&sn=739d80488fe1169a9c9ca26ecfcdfba6&chksm=fa0e6b0ccd79e21a1c2b0d99db69f6206cddddfe2367742e9de1d7d17ec35a5ce29fa4e30d63&token=110841213&lang=zh_CN#rd
      **/
    def droppingCups(cups: Int, floors: Int): Int = {
      val arr = Array.ofDim[Int](cups + 1, floors + 1)
      for (i <- 0 to floors) {
        arr(0)(i) = 0
        arr(1)(i) = i
      }
      for (i <- 2 to cups) {
        arr(i)(0) = 0
        arr(i)(1) = 1
      }
      for (i <- 2 to cups) {
        for (j <- 2 to floors) {
          var max = Int.MaxValue
          for (k <- 1 until j) {
            val t = Math.max(arr(i)(j - k), arr(i - 1)(j - 1))
            if (max > t) max = t
          }
          arr(i)(j) = max + 1
        }
      }
      arr(cups, floors)
    }


# 外观数列

<https://leetcode-cn.com/problems/count-and-say/>

    public String countAndSay(int n) {
        if(n==1) return "1";
        if(n==2) return "11";
        String str = countAndSay(n-1);
    
        char start = str.charAt(0);
        int count=1;
        StringBuilder res = new StringBuilder("");
        for(int i=1; i<str.length(); i++){
            if(str.charAt(i)==start){
                count++;
            }else{
                res.append(count).append(start);
                count = 1;
                start = str.charAt(i);
            }
        }
        res.append(count).append(start);
        return res.toString();
    }


# 有序数组的平方

<https://leetcode-cn.com/problems/squares-of-a-sorted-array/>
双指针

    public int[] sortedSquares(int[] A) {
        int len = A.length, i = 0;//读取非负数的指针
        while(i<len && A[i]<0){
            i++;
        }
        int j = i-1;//读取负数的指针
        int[] res = new int[len];
        int k = 0;//记录新数组的指针
        while(i<len && j>=0){
            res[k++] = A[i]*A[i]<A[j]*A[j]? A[i]*A[i++] : A[j]*A[j--];
        }
        while(i<len){
            res[k++] = A[i]*A[i++];
        }
        while(j>=0){
            res[k++] = A[j]*A[j--];
        }
        return res;
    }


# 树


## 相同的树

<https://leetcode-cn.com/problems/same-tree/>


### 递归

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        return p.val==q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }


## 对称二叉树

<https://leetcode-cn.com/problems/symmetric-tree/>


### 递归

    public boolean isSymmetric(TreeNode root) {
        return isMirro(root, root);
    }
    public boolean isMirro(TreeNode left, TreeNode right){
        if(left==null && right==null) return true;
        if(left==null || right==null) return false;
        return left.val==right.val
                && isMirro(left.left, right.right)
                && isMirro(left.right, right.left);
    }


### 迭代

    public boolean isSymmetric(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode t1 = queue.poll(), t2 = queue.poll();
            if(t1==null && t2==null) continue;
            if(t1==null || t2==null) return false;
            if(t1.val!=t2.val) return false;
            queue.offer(t1.left);
            queue.offer(t2.right);
            queue.offer(t1.right);
            queue.offer(t2.left);
        }
        return true;
    }


## 二叉树层次遍历

<https://leetcode-cn.com/problems/binary-tree-level-order-traversal/>


### BFS

    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int curSize = queue.size();
            List<Integer> curRes = new ArrayList<>();
            for(int i=0; i<curSize; i++){
                TreeNode t = queue.poll();
                curRes.add(t.val);
                if(t.left!=null) queue.offer(t.left);
                if(t.right!=null) queue.offer(t.right);
            }
            res.add(curRes);
        }
        return res;
    }


## 二叉树层次遍历 ii

<https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/>


### BFS

    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if(root==null) return new ArrayList<>();
        LinkedList<List<Integer>> res = new LinkedList<>();
    
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int max = 1;//找最大宽度
        while(!queue.isEmpty()){
            int size = queue.size();//本层宽度
            List<Integer> curLevel = new ArrayList<>();
            max = Math.max(max, size);
            for(int i=0;i<size;i++){
                TreeNode t = queue.poll();
                curLevel.add(t.val);
                if(t.left!=null) queue.offer(t.left);
                if(t.right!=null) queue.offer(t.right);
            }
            res.addFirst(curLevel);
        }
        return res;
    }


## 二叉树最小深度

<https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/>

    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        //1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可
        if(root.left==null && root.right==null) return 1;
        //2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度
        int le = minDepth(root.left);
        int ri = minDepth(root.right);
        if(root.left==null || root.right==null) return le+ri+1;
        //3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可
        return Math.min(le,ri)+1;
    }


## 有序数组转换为二叉树

<https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/>

    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums==null || nums.length==0) return null;
        return merge(nums, 0, nums.length-1);
    }
    
    public TreeNode merge(int[] nums, int L, int R){
        if(L>R) return null;
        if(L==R) return new TreeNode(nums[L]);
        int mid = L+(R-L)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = merge(nums, L, mid-1);
        root.right = merge(nums, mid+1, R);
        return root;
    }


## 平衡二叉树

<https://leetcode-cn.com/problems/balanced-binary-tree/>


### 自底至顶 Bottom-Up

    public boolean isBalanced(TreeNode root) {
        return depth(root)!=-1;
    }
    public int depth(TreeNode root){
        if(root==null) return 0;
        int left = depth(root.left);
        if(left==-1) return -1;
        int right = depth(root.right);
        if(right==-1) return -1;
        return Math.abs(left-right)<2? Math.max(left,right)+1:-1;
    }


### 自顶至底 Top-Down

    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        return Math.abs(depth(root.left)-depth(root.right))<=1 
            && isBalanced(root.left) 
            && isBalanced(root.right);
    }
    
    public int depth(TreeNode root){
        if(root==null) return 0;
        return Math.max(depth(root.left), depth(root.right))+1;
    }

