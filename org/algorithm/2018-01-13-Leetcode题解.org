# -*-mode:org;coding:utf-8-*-
# Created:  zhuji 02/11/2020
# Modified: zhuji 02/11/2020 17:45

#+OPTIONS: toc:nil num:t
#+BIND: org-html-link-home "https://zhujing0227.github.io/images/"
#+TITLE: Leetcode 题解

#+begin_export md
---
layout: post
title: Leetcode 题解
categories: Algorithm
tags: [algorithm, Leetcode]
comments: true
---
#+end_export

* Table of Contents                                                     :TOC:
- [[#two-sum][Two Sum]]
  -  [[#暴力求解-on2][暴力求解 O(n^2)]]
  -  [[#hashmap-on][HashMap O(n)]]
- [[#maximum-subarray-最大子数组][Maximum Subarray 最大子数组]]
  - [[#线性时间算法-on][线性时间算法. O(n)]]
  - [[#分治算法-onlg-n][分治算法. O(nlg n)]]
  - [[#动态规划-on][动态规划. O(n)]]
- [[#unique-paths-唯一路径][Unique Paths 唯一路径]]
  - [[#递归求解][递归求解]]
  - [[#动态规划-omn][动态规划 O(m*n)]]
  - [[#dp-优化-空间复杂度从-omn 降到-ominm-n][DP 优化: 空间复杂度从 O(m*n)降到 O(min(m, n))]]
- [[#kth-largest-element-in-an-array][Kth Largest Element in an Array]]
  - [[#快排法---参考快速排序][快排法   参考快速排序]]
  - [[#最小堆法--参考最小堆法][最小堆法  参考最小堆法]]
- [[#add-two-numbers][Add Two Numbers]]
- [[#linked-list-cycle-循环链表][Linked List Cycle 循环链表]]
  - [[#拓展][拓展]]
- [[#intersection-of-two-linked-lists-链表相交][intersection-of-two-linked-lists 链表相交]]
- [[#water-and-jug--水壶问题][water and jug  水壶问题]]
- [[#过桥问题][过桥问题]]
- [[#位操作][位操作]]
  - [[#single-number][single number]]
    - [[#1-single-number1][1 single-number1]]
    - [[#2-single-number2][2 single-number2]]
    - [[#3-single-number3][3 single-number3]]
  - [[#poor-pigs-小白鼠试毒][poor pigs 小白鼠试毒]]
    - [[#1-初级版问题每只只能试一次][1 初级版问题——每只只能试一次]]
    - [[#2-中级版问题每只可以实验多次][2 中级版问题——每只可以实验多次]]
  - [[#power-of-two][power of two]]
    - [[#1-power-of-three][1. power of three]]
    - [[#2-power-of-four][2. power of four]]
  - [[#missing-number-缺失的數字][missing number 缺失的數字]]
  - [[#数字范围按位与][数字范围按位与]]
  - [[#位-1-的个数][位 1 的个数]]
  - [[#颠倒二进制][颠倒二进制]]
  - [[#判断二进制的第-n-位为-1-或-0][判断二进制的第 n 位为 1 或 0]]
  - [[#将二进制的第-n-位设置为-1][将二进制的第 n 位设置为 1]]
  - [[#将二进制的第-n-位设置为-0][将二进制的第 n 位设置为 0]]
- [[#powx-n][powx-n]]
- [[#寻找重复数][寻找重复数]]
- [[#快乐数][快乐数]]
- [[#各位相加][各位相加]]
- [[#最长回文子串][最长回文子串]]
- [[#有效的括号][有效的括号]]
- [[#简化路径][简化路径]]
- [[#玻璃杯检测][玻璃杯检测]]

* Two Sum

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
#+begin_example
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
#+end_example

**  暴力求解 O(n^2)
#+begin_example
two-sum(A, key):
for i=1 to A.length-1
    for j=i+1 to A.length
        if A[i] + A[j] = key
            return [i,j]
#+end_example

**  HashMap O(n)
   保存数组的元素和索引, 遍历过程在 map 中找(key-A[i]), 若存在则返回[i, map.get(key-A[i])]
#+begin_src java
  private static int[] findTwoSum(int[] arr, int key) {
      Map<Integer, Integer> map = new HashMap<>(arr.length);
      for (int i = 0; i < arr.length; i++) {
          if (map.containsKey(key - arr[i])) {
              return new int[]{map.get(key - arr[i]), i};
          }
          map.put(arr[i], i);
      }
      throw new RuntimeException("No two sum solution");
  }
#+end_src
   ------------
* Maximum Subarray 最大子数组

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2, 1, -3, 4, -1, 2, 1, -5, 4], 

the contiguous subarray [4, -1, 2, 1] has the largest sum = 6.

** 线性时间算法. O(n)

curSum 记录每次迭代 A[0..i]的最大子数组
#+begin_src java
  private static int maxSubArray(int[] arr) {
      if (arr.length == 1) return arr[0];

      int max = arr[0], curSum = arr[0];
      for (int i = 1; i < arr.length; i++) {
          curSum = Math.max(curSum + arr[i], arr[i]);
          max = Math.max(max, curSum);
      }
      return max;
  }
#+end_src

** 分治算法. O(nlg n)

最大子数组必定在左半部分/有半部分或跨越中间的, 分别计算三部分的最大子数组, 三者最大值即为最终的最大子数组.
#+begin_src java
  private static int maxSubArrayDivide(int[] arr, int left, int right) {
      if (left >= right) {
          return arr[left];
      }

      int mid = left + ((right - left) >> 1);
      //左半部分最大子数组
      int leftSum = maxSubArrayDivide(arr, left, mid);
      //右半部分最大子数组
      int rightSum = maxSubArrayDivide(arr, mid + 1, right);
      //跨越中点的最大子数组
      int crossSum = crossMiddle(arr, left, mid, right);

      return Math.max(leftSum, Math.max(rightSum, crossSum));
  }

  private static int crossMiddle(int[] arr, int left, int mid, int right) {
      int sum = 0, leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE;
      //从 mid 出发, 左边最大子数组
      for (int i = mid; i >= left; i--) {
          sum += arr[i];
          if (sum > leftMax) {
              leftMax = sum;
          }
      }

      sum = 0;
      //从 mid+1 出发右边最大子数组
      for (int i = mid + 1; i <= right; i++) {
          sum += arr[i];
          if (sum > rightMax) {
              rightMax = sum;
          }
      }
      return leftMax + rightMax;
  }
#+end_src

** 动态规划. O(n)

与线性时间一样, 只是保存了每一步的最大子数组
#+begin_src java
  public static int maxSubArrayDP(int[] arr) {
      //dp[i] means the maximum subarray ending with A[i];
      int[] dp = new int[arr.length];
      dp[0] = arr[0];
      int max = dp[0];

      for(int i = 1; i < arr.length; i++){
          dp[i] = Math.max(arr[i], dp[i-1] + arr[i]);
          max = Math.max(max, dp[i]);
      }
      return max;
  }
#+end_src

------------
* Unique Paths 唯一路径

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

** 递归求解

当前位置的结果 = 从当前位置向下走一步的结果 + 与从当前位置向右走一步的结果
#+begin_src java
  private static int uniquePathsRecursive(int m, int n) {
      if (m == 0 || n == 0) {
          return 0;
      }
      if (m == 1 || n == 1) {
          return 1;
      }
      return uniquePathsRecursive(m, n - 1) + uniquePathsRecursive(m - 1, n);
  }
#+end_src

** 动态规划 O(m*n)

递归存在大量重复的计算, 动态规划中使用数组保存了之前的计算结果.
#+begin_src java
  private static int uniquePaths(int m, int n) {
      int[][] tab = new int[m][n];

      for (int i = 0; i < m; i++) {
          for (int j = 0; j < n; j++) {
              if (i == 0 || j == 0) {
                  tab[i][j] = 1;
              } else {
                  tab[i][j] = tab[i - 1][j] + tab[i][j - 1];
              }
          }
      }
      return tab[m - 1][n - 1];
  }
#+end_src

** DP 优化: 空间复杂度从 O(m*n)降到 O(min(m, n))
#+begin_src java
  private static int uniquePaths(int m, int n){
      //assume m >= n
      if(m < n){
          int t = m;
          m = n;
          n = t;
      }
      int[] tab = new int[n];
      tab[0] = 1;

      for(int i = 0; i < m; i++){
          for(int j = 1; j < n; j++){
              tab[j] += tab[j - 1];
          }
      }
      return tab[n - 1];
  }
#+end_src

------------
* Kth Largest Element in an Array

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

For example, 

Given [3, 2, 1, 5, 6, 4] and k = 2, return 5.

** 快排法   参考[[./排序之快排][快速排序]]
   #+begin_src java
     public int findKthLargest(int[] arr, int p, int r, int k) {
         int q = partition(arr, p, r);
         int len = q - p + 1;
         if (len == k) {
             return arr[q];
         } else if (len < k) {
             return findKthLargest(arr, q + 1, r, k - len);
         } else {
             return findKthLargest(arr, p, q - 1, k);
         }
     }

     public static int partition(int[] arr, int p, int r) {
         int x = arr[r], i = p - 1;
         for (int j = p; j < r; j++) {
             if (arr[j] >= x) {
                 //swap arr[++i] and arr[j]
                 swap(arr, ++i, j);
             }
         }
         //swap arr[i+1] and arr[r]
         swap(arr, ++i, r);
         return i;
     }
     public static void swap(int[] arr, int i, int j) {
         int tmp = arr[i];
         arr[i] = arr[j];
         arr[j] = tmp;
     }
#+end_src

** 最小堆法  参考[[./排序之堆排序][最小堆法]]
   用原数组 A[0, k-1]构建 k 个元素的最小堆, 遍历 A[k, A.length-1], if(A[0] < A[i]), then swap A[0] with A[i], 维护最小堆的性质, 遍历结束后 A[0]即为 Kth Largest Element in an Array.
   #+begin_src java
     public static int findKthMaxWithMinHeap(int[] arr, int k) {
         MinHeapSort minHeapSort = new MinHeapSort(arr, k);  //用数组前 k 个数构建一个最小堆
         for (int i = k; i < arr.length; i++) {
             if (arr[0] < arr[i]) {
                 swap(arr, 0, i);
                 minHeapSort.minHeapify(0);
             }
         }
         return arr[0];
         //return Arrays.stream(arr).limit(k).toArray(); //返回前 k 个最大的数
     }
   #+end_src

   与之类似求 Kth Smallest Element in an Array 可以用[[./排序之堆排序][最大堆]]求解

------------
* Add Two Numbers

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example
#+begin_quote
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
#+end_quote

两个链表依次从低位开始相加, 新的链表节点只保存与 10 的余数(Sum%10), Sum/10 累加到高位, 一个链表到末尾节点后以 0 占位, 直至两链表都到末尾节点.
#+begin_src java
  private static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
      ListNode listNode = new ListNode(0), curr = listNode;
      int carry = 0;
      while (l1 != null || l2 != null || carry != 0) {
          int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;
          curr.next = new ListNode(sum % 10);
          curr = curr.next;
          carry = sum / 10;

          if (l1 != null) l1 = l1.next;
          if (l2 != null) l2 = l2.next;
      }
      return listNode.next;
  }

  @ToString
  static class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {this.val = x;}
      ListNode(int x, ListNode next){
          this(x);
          this.next = next;
      }
  }
#+end_src

------------
* Linked List Cycle 循环链表

Given a linked list, determine if it has a cycle in it.

利用快慢两个指针, 如果链表存在环, 那么必然存在某个点快慢两个指针重合.
#+begin_src java
  public boolean hasCycle(ListNode head) {
      if (head == null || head.next == null) {
          return false;
      }

      ListNode slow = head, fast = head;
      while(fast != null && fast.next != null){
          slow = slow.next;
          fast = fast.next.next;
          if(slow == fast)    return true;
      }
      return false;
  }
  class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {
          val = x;
          next = null;
      }
  }
#+end_src

** 拓展

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

在判断了存在环的情况下, 设 head 节点到环起点距离为 A, 起点到 slow 节点距离为 B, 环长为 C.

slow 指针移动距离为 A+B, fast 指针移动距离为 A+B+C, 2(A+B) = A+B+C => C = A+B, slow 指针继续移动到起点的距离为 C-B = A, 即 head 与 slow 同步移动, 当 head==slow 时, 即为环的起点.
#+begin_src java
public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast){
            ListNode s = head;
            while (s != slow){
                s = s.next;
                slow = slow.next;
            }
            return s;
        }
    }
    return null;
}
#+end_src

------------
* intersection-of-two-linked-lists 链表相交

https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/
#+begin_src scala
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
        **/
        if(headA == null || headB == null) return null;
        ListNode p1 = headA, p2 = headB;
        // 在这里第一轮体现在 pA 和 pB 第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果 pA 或 pB 相交就返回交点, 不相交最后就是 null==null
        while (p1 != p2) {
            p1 = p1 == null ? headB : p1.next;
            p2 = p2 == null ? headA : p2.next;
        }
        return p1;
    }
}
#+end_src

* water and jug  水壶问题
https://leetcode-cn.com/problems/water-and-jug-problem/
#+begin_src java
  /*
   ,* 这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为 x 和 y，
   ,* 问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为 z 升。
   ,* 那么我们可以用一个公式来表达：
   ,* z = m * x + n * y
   ,* 其中 m，n 为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，
   ,* 那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即 3 升的水罐往外倒了两次水，
   ,* 5 升水罐往里舀了两次水。那么问题就变成了对于任意给定的 x,y,z，存不存在 m 和 n 使得上面的等式成立。
   ,* 根据裴蜀定理，ax + by = d 的解为 d = gcd(x, y)，那么我们只要只要 z % d == 0，上面的等式就有解，
   ,* 所以问题就迎刃而解了，我们只要看 z 是不是 x 和 y 的最大公约数的倍数就行了，
   ,* 别忘了还有个限制条件 x + y >= z，因为 x 和 y 不可能称出比它们之和还多的水
   ,* */
  class Solution {
      public boolean canMeasureWater(int x, int y, int z) {
          return z==0 ||
              (z<=x+y && z%gcd(x,y)==0);
      }
   
      /**
      ,*  最大公约数：欧几里得算法
      ,* gcd(a,b) = gcd(b,a mod b)
      ,**/
      static int gcd(int x, int y){
          return y==0 ? x : gcd(y,x%y);
      }
   
      /**
      ,*最小公倍数：lcm(x,y)=x*y/gcd(x,y)
      ,*/*
      static int lcm(int x, int y){
          return x*y/gcd(x,y);
      }
  }
#+end_src

* 过桥问题
https://blog.csdn.net/xiji333/article/details/88072469
n 个人要晚上过桥，在任何时候最多两个人一组过桥，每组要有一只手电筒。在这 n 个人中只有一个手电筒能用，因此要安排以某种往返的方式来返还手电筒，使更多的人可以过桥。
#+begin_src scala
  object Bridge {

    def main(args: Array[String]): Unit = {
      val bridges = StdIn.readLine("输入过桥的人名及各自的时间")
        .split(" ")
        .map(l => {
          val split = l.split(",")
          split(0) -> split(1).toInt
        }).sortBy(_._2).toList
      calBridge(bridges, 0)
    }

    def calBridge(people: List[(String, Int)], time: Int): Unit = {
      people.size match {
        case 1 | 2 => {
          //A B 一块过桥 耗时 B
          println(s"${people.head._1} ${people.last._1} 过桥时间:${people.last._2}")
          println(s"总耗时: ${time + people.last._2}")
        }
        case 3 => {
          //A 送两次 耗时 B+A+C
          print(
            s"""|${people(1)._1} ${people.head._1} 过桥时间:${people(1)._2}
                |${people.head._1} 返回时间:${people.head._2}
                |${people(2)._1} ${people.head._1} 过桥时间:${people(2)._2}
                |总耗时: ${time + people.map(_._2).sum}
                |""".stripMargin)
        }
        case _ => {
          //A B C D
          //1. 最快的两个分别送两个最慢的过桥 B+A+D+B=A+2B+D
          //2. 最快者送最慢的两个过桥 C+A+D+A=2A+C+D
          val time1 = people.head._2 + 2 * people(1)._2 + people(3)._2
          val time2 = 2 * people.head._2 + people(2)._2 + people(3)._2
          if (time1 < time2) {
            print(
              s"""|${people(1)._1} ${people.head._1} 过桥时间:${people(1)._2}
                  |${people.head._1} 返回时间:${people.head._2}
                  |${people(2)._1} ${people(3)._1} 过桥时间:${people(3)._2}
                  |${people(1)._1} 返回时间:${people(1)._2}
                  |""".stripMargin)
            calBridge(people.take(people.size - 2), time + time1)
          } else {
            print(
              s"""|${people(2)._1} ${people.head._1} 过桥时间:${people(2)._2}
                 |${people.head._1} 返回时间:${people.head._2}
                  |${people(3)._1} ${people.head._1} 过桥时间:${people(3)._2}
                  |${people.head._1} 返回时间:${people.head._2}
                  |""".stripMargin)
            calBridge(people.take(people.size - 2), time + time2)
          }
        }
      }
    }
  }
#+end_src

* 位操作
  [[https://mp.weixin.qq.com/s/99HVijYmbk1BrGVi1BqrCg][位操作奇技淫巧之原理加实践]]
  #+begin_example
  0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为 1，奇数位为 0）
  0x55555555 = 1010101010101010101010101010101 (偶数位为 0，奇数位为 1）
  0x33333333 = 110011001100110011001100110011 (1 和 0 每隔两位交替出现)
  0xcccccccc = 11001100110011001100110011001100 (0 和 1 每隔两位交替出现)
  0x0f0f0f0f = 00001111000011110000111100001111 (1 和 0 每隔四位交替出现)
  0xf0f0f0f0 = 11110000111100001111000011110000 (0 和 1 每隔四位交替出现)
  0xffffffff = 11111111111111111111111111111111
  #+end_example
** single number
*** 1 single-number1
 https://leetcode.com/problems/single-number/
 #+begin_src scala
   /**
     ,* arr 中有一个数只出现一次, 其他数都是出现两次, 找出只出现一次的数.
     ,* [1,1,2,2,3] => 3
     ,*/
   def singleNumber(nums: Array[Int]): Int = {
     nums.reduce(_^_)
   }
 #+end_src

*** 2 single-number2
 https://leetcode-cn.com/problems/single-number-ii/
 #+begin_src scala
 /**
   * https://leetcode-cn.com/problems/single-number-ii, 老鼠试毒
   * arr 中只有一个数出现一次, 其他数都出现 k 次, 找出只出现一次的数
   * 假设输入中没有 single number，那么输入中的每个数字都重复出现了数字，也就是说，对这 32 位中的每一位 i 而言，所有的输入加起来之后，第 i 位一定是 3 的倍数。
   * 现在增加了 single number，那么对这 32 位中的每一位做相同的处理，也就是说，逐位把所有的输入加起来，并且看看第 i 位的和除以 3 的余数，这个余数就是 single numer 在第 i 位的取值。这样就得到了 single number 在第 i 位的取值。这等价于一个模拟的二进制，接着只需要把这个模拟的二进制转化为十进制输出即可
   */
 def uniqueNumberK(arr: Array[Int], k: Int): Int = {
   var ans = 0
   val len = arr.length
   val temp = Array.ofDim[Int](32)
   for (i <- 0 until 32) {
     for (j <- 0 until len) {
       temp(i) += ((arr(j) >> i) & 1)
     }
     temp(i) = temp(i) % k
     ans |= (temp(i) << i)
   }
   ans
 }
 #+end_src

*** 3 single-number3
 https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leetcode/
 #+begin_src scala
 /**
   * arr 中有两个个数只出现一次, 其他数都是出现两次, 找出只出现一次的两个数.
   * 数组中所有数异或后的值就是出现一次的两个数异或的结果, 找到其第一次出现 1 的位数, 根据该位是否为 1 将数据分成两组,
   * 分别对两组数求异或值, 就能得到只出现一次的两个数
   * [1,1,2,2,3,4] => 3,4
   */
 def uniqueNumberV2(arr: Array[Int]): Array[Int] = {
   val xor = arr.reduce((a, b) => a ^ b)
   val mask = xor & (-xor)//保留位中最右边的 1
   var a = 0
   var b = 0
   for (i <- arr) {
     if ((i & mask) == 0) {
       a ^= i
     } else {
       b ^= i
     }
   }
   Array(a, b)
 }
 #+end_src

 ------------
** poor pigs 小白鼠试毒
 https://blog.csdn.net/haolexiao/article/details/72843286

 通用方法是讲试剂中哪瓶是毒品的信息总数表示出来为 N，然后再找出小白鼠所能表示的状态数目为 M，则需要的小白鼠个数为：K=logMN
 而具体实验的操作方法为：
 #+begin_quote
 1. 将每种状态按照 M 进制进行编码，编码长度为 K
 2. 每个小白鼠分别去拿自身的 M 中状态去实验 N 的 M 进制编码的某一位
 3. 所以 K 个小白鼠，等同于是 K 长度 M 进制的对应的每一位
 4. 这样试验完后，就确定了每一位上面的数字，找到对应的那种状态就好。
 #+end_quote

*** 1 初级版问题——每只只能试一次
    #+begin_example
    /**
    * 1000 瓶水里有一瓶水有毒, 给 10 只小白鼠让找出有毒的是哪瓶
    * 1000 瓶水编号 1-1000, 10 只小白鼠按照二进制编号, 0 没喝水, 1 喝水了
    * 1 号瓶, 一号小白鼠喝 =>          0000000001
    * 3 号瓶, 一号和二号小白鼠都喝 =>   0000000011
    * .....
    * 最后看哪些小白鼠死了, 将 1 填充到对应的编号
    * 5,6 号死了 => 0000110000 => 48 号瓶有毒
    * 4,6,7,8 号四了 => 0011101000 => 232 号有毒
    */
    ceil(log(1000)/log(2)) = 10
    #+end_example

*** 2 中级版问题——每只可以实验多次
 https://leetcode-cn.com/problems/poor-pigs
 #+begin_src java
   public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
       int scale = minutesToTest/minutesToDie + 1;//一只猪能代表的状态
       return (int) Math.ceil(Math.log(buckets)/Math.log(scale*1.0));
   }
 #+end_src

 ------------
** power of two
 https://leetcode-cn.com/problems/power-of-two/
 #+begin_src scala
   /**
     ,* 231 https://leetcode-cn.com/problems/power-of-two/
     ,* 判断一个整数是否为 2 的幂次方
     ,* 4 => true, 5 => false
     ,* 4&3=>0, 8&7=>0
     ,*/
   def powerOfTwo(num: Int): Boolean = {
     num > 0 && (num & (num - 1)) == 0
   }
 #+end_src

*** 1. power of three
 https://leetcode-cn.com/problems/power-of-two/
 #+begin_src scala
   /**
     ,* 转成三进制后, 只有一位是 1
     ,* 1 =>  0001
     ,* 3 =>  0010
     ,* 9 =>  0100
     ,* 27=>  1000
     ,* 326 https://leetcode-cn.com/problems/power-of-three/
     ,*
     ,*/
   def isPowerOfThree(n: Int): Boolean = {
     Integer.toString(n, 3).matches("10*")
   }
 #+end_src

*** 2. power of four
 https://leetcode-cn.com/problems/power-of-four/
 #+begin_src scala
   /**
     ,* 342 https://leetcode-cn.com/problems/power-of-four/
     ,* 判断一个整数是否为 4 的幂次方
     ,* 4 的幂次方转为二进制后, 1 出现在奇数位上, 4=>3; 16=>5; 64=>7
     ,* 00000000000000000000000000000100  => 4
     ,* 00000000000000000000000000010000  => 16
     ,* 00000000000000000000000001000000  => 64
     ,* 如果是 4 的幂次方, 与 1010101010101010101010101010101 按位与后必然与自身相等
     ,*/
   def powerOfFour(num: Int): Boolean = {
     //1010101010101010101010101010101
     num > 0 && (num & (num - 1)) == 0 && (num & 0x55555555) == num
   }
 #+end_src

 ------------
** missing number 缺失的數字
   https://leetcode-cn.com/problems/missing-number/
   #+BEGIN_SRC scala
       /**
         ,* 268
         ,* 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数
         ,* 0,1,3 => 2
         ,* 0,1,3 ^ 1,2,3 => 2
         ,**/
       def missingNumber(array: Array[Int]): Int = {
         var ans = 0
         for ((i, index) <- array.zipWithIndex) {
           ans ^= i
           ans ^= index + 1
         }
         ans
       }
   #+END_SRC
** 数字范围按位与
   https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/
   #+BEGIN_SRC scala
     def rangeBitwiseAnd(m: Int, n: Int): Int = {
         var mask = 0xffffffff//11111111111111111111111111111111
         while ((mask & m) != (mask & n)) {
             mask = mask << 1
         }
         mask & m
     }
   #+END_SRC
   #+BEGIN_SRC scala
     def rangeBitwiseAnd(m: Int, n: Int): Int = {
         // n&(n-1)会把最后一个 1 后面所有位都置为 0,有点类似找 m 和 n 二进制的公共前缀
         var offset = 0//记录右移次数
         var mm = m
         var nn = n
         while(mm != nn){
             mm >>= 1
             nn >>= 1
             offset += 1
         }
         mm << offset
     }
   #+END_SRC
   #+BEGIN_SRC java
     public int rangeBitwiseAnd(int m, int n) {
         while(n > m){//直到 m 大于等于 n
             n &= (n-1);
         }
         return n;
     }
   #+END_SRC

** 位 1 的个数
   https://leetcode-cn.com/problems/number-of-1-bits/
   #+BEGIN_SRC java
     public int hammingWeight(int n) {
         int res = 0;
         while(n!=0){
             if((n&1)==1) res+=1;
             n = n >>> 1;//注意用无符号右移
         }
         return res;
     }
   #+END_SRC
   #+BEGIN_SRC java
     public int hammingWeight(int n) {
         int res = 0;
         while(n!=0){
             res+=1;
             n = n & (n - 1);
         }
         return res;
     }
   #+END_SRC

** 颠倒二进制
   https://leetcode-cn.com/problems/reverse-bits/
   #+BEGIN_SRC java
     //循环搬运 n 的各位到 ans 上
     public int reverseBits(int n) {
         int ans = 0;
         for (int i = 0; i < 32; i++) {
             ans <<= 1;//ans 左移一位，给 n 的最后一位挪个窝
             ans += (n&1);//n 和 1 与，取出 n 的最后一位，放在 ans 的最后一位
             n >>= 1;//n 右移一位，把已经挪到 ans 中的最后一位释放掉
         }
         return ans;
     }
   #+END_SRC

** 判断二进制的第 n 位为 1 或 0
   #+begin_example
   x & (1<<n)
   #+end_example

** 将二进制的第 n 位设置为 1
   #+begin_example
   x | (1<<n)
   #+end_example

** 将二进制的第 n 位设置为 0
   #+begin_example
   x & ~(1<<n)
   #+end_example

* powx-n
https://leetcode-cn.com/problems/powx-n/submissions/
#+begin_src java
  public static double myPow(double x, int n) {
      int m = n >= 0 ? n : -n;
      double res = myPowRec(x, m);
      return n >= 0 ? res : 1 / res;
  }

  public static double myPowRec(double x, int n) {
      if (n == 0) return 1;
      if (n == 1) return x;
      double tmp = myPowRec(x, n / 2);
      if ((n & 1) == 0) {
          return tmp * tmp;
      } else {
          return tmp * tmp * x;
      }
  }
#+end_src

* 寻找重复数
  https://leetcode-cn.com/problems/find-the-duplicate-number/
  #+BEGIN_SRC scala
    /**
      ,* 287
      ,* 二分法。对“数”做二分，要定位的“数”根据题意在 1 和 n 之间，每一次二分都可以将搜索区间缩小一半。
      ,*
      ,* 以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，
      ,* 遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 [1,4)（注意：左闭右开）中；
      ,* 否则，重复的数存在于区间 [4,7]D（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），
      ,* 因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。
      ,*/
    def findDuplicate(nums: Array[Int]): Int = {
      var left = 0
      var right = nums.length - 1
      while (left < right) {
        val mid = left + (right - left + 1) / 2
        var count = 0
        for (n <- nums) {
          if (n < mid) count += 1
        }
        if (count < mid) {
          left = mid
        } else {
          right = mid - 1
        }
      }
      left
    }
  #+END_SRC

* 快乐数
  https://leetcode-cn.com/problems/happy-number/
  #+BEGIN_SRC scala
    /**
      ,* 202 https://leetcode-cn.com/problems/happy-number
      ,* 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，
      ,* 也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数
      ,* 缓存每次计算的结果, 如果出现重复则说明跳进了循环, 直接退出
      ,*/
    def isHappy(happy: Int): Boolean = {
      var h = happy
      var seed = Set(1)
      while (!seed.contains(h)) {
        seed = seed + h
        h = h.toString.map(i => Math.pow(i.toString.toInt, 2).toInt).sum
      }
      h == 1
    }
  #+END_SRC
  #+BEGIN_SRC scala
    //参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题
    //如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是
    //两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于 1。
    def isHappy(n: Int): Boolean = {
        var fast = n
        var slow = n
        do{
            slow = squareSum(slow)
            fast = squareSum(squareSum(fast))
        }while(slow!=fast)
        fast == 1
    }
    def squareSum(m:Int):Int={
        m.toString.map(i => Math.pow(i.toString.toInt, 2).toInt).sum
    }
  #+END_SRC
* 各位相加
  https://leetcode-cn.com/problems/add-digits/
  #+BEGIN_SRC scala
    /**
      ,* 258 https://leetcode-cn.com/problems/add-digits/
      ,* 假设一个三位数整数 n=100*a+10*b+c,变化后 addn=a+b+c； 两者的差值 n-addn=99a+9b，差值可以被 9 整除，
      ,* 说明每次缩小 9 的倍数 那么我们可以对 res=num%9，若不为 0 则返回 res，为 0 则返回 9
      ,*/
    def addDigits(num: Int): Int = {
      if (num > 0 && num % 9 == 0) 9 else num % 9
    }
  #+END_SRC
* 最长回文子串
  https://leetcode-cn.com/problems/longest-palindromic-substring/
  #+BEGIN_SRC java
    /**
      ,* 5 https://leetcode-cn.com/problems/longest-palindromic-substring/
      ,* https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/
      ,* P(i,j)=(P(i+1,j−1)&&S[i]==S[j])
      ,*/
    def longestPalindrome(s: String): String = {
      val len = s.length
      var res = ""
      val dp = Array.ofDim[Boolean](len, len)
      for (i <- len - 1 to(0, -1)) {
        for (j <- i until len) {
          dp(i)(j) = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp(i + 1)(j - 1))
          if (dp(i)(j) && res.length < j - i + 1) {
            res = s.substring(i, j + 1)
          }
        }
      }
      res
    }
  #+END_SRC
* 有效的括号
  https://leetcode-cn.com/problems/valid-parentheses/
  #+BEGIN_SRC java
    /**
      ,* 20 https://leetcode-cn.com/problems/valid-parentheses/
      ,*/
    def isValid(s: String): Boolean = {
      val map = Map(')' -> '(', '}' -> '{', ']' -> '[')
      val stack = new mutable.ArrayStack[Char]()
      for (c <- s) {
        if (map.contains(c)) {
          val top = if (stack.isEmpty) '#' else stack.pop()
          if (top != map(c)) return false
        } else {
          stack.push(c)
        }
      }
      stack.isEmpty
    }
  #+END_SRC
* 简化路径
  https://leetcode-cn.com/problems/simplify-path/
  #+BEGIN_SRC java
    /**
      ,* 71 https://leetcode-cn.com/problems/simplify-path/
      ,* 简化路径
      ,*/
    def simplifyPath(s: String): String = {
      val stack = new mutable.ArrayStack[String]()
      s.split("/")
        .foreach(c => {
          if (c.equals("..")) {
            if (stack.nonEmpty) stack.pop()
          } else if (c.nonEmpty && !c.equals(".")) {
            stack.push(c)
          }
        })
      "/" + stack.toList.reverse.mkString("/").replaceFirst("/$", "")
    }
  #+END_SRC
* 玻璃杯检测
  [[https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484557&idx=1&sn=739d80488fe1169a9c9ca26ecfcdfba6&chksm=fa0e6b0ccd79e21a1c2b0d99db69f6206cddddfe2367742e9de1d7d17ec35a5ce29fa4e30d63&token=110841213&lang=zh_CN#rd][玻璃被检测]]
  #+BEGIN_SRC scala
    /**
      ,* 有一种玻璃杯质量确定但未知，需要检测。
      ,* 有一栋 100 层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。
      ,* 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎
      ,* W(n, k) = 1 + min{max(W(n -1, x -1), W(n, k - x))}, x in {2, 3, ……，k}
      ,* https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484557&idx=1&sn=739d80488fe1169a9c9ca26ecfcdfba6&chksm=fa0e6b0ccd79e21a1c2b0d99db69f6206cddddfe2367742e9de1d7d17ec35a5ce29fa4e30d63&token=110841213&lang=zh_CN#rd
      ,**/
    def droppingCups(cups: Int, floors: Int): Int = {
      val arr = Array.ofDim[Int](cups + 1, floors + 1)
      for (i <- 0 to floors) {
        arr(0)(i) = 0
        arr(1)(i) = i
      }
      for (i <- 2 to cups) {
        arr(i)(0) = 0
        arr(i)(1) = 1
      }
      for (i <- 2 to cups) {
        for (j <- 2 to floors) {
          var max = Int.MaxValue
          for (k <- 1 until j) {
            val t = Math.max(arr(i)(j - k), arr(i - 1)(j - 1))
            if (max > t) max = t
          }
          arr(i)(j) = max + 1
        }
      }
      arr(cups, floors)
    }
  #+END_SRC
